#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
**mat.py**
phoebe implementation

in the module:
* *class* **Mat**

Copyright (c) 2017-2019 Jarosław Stańczyk <j.stanczyk@hotmail.com>
"""
# pylint: disable=invalid-name
from builtins import range, len, staticmethod, enumerate, sorted, str

import inf
from yml import Yml
from err import Err


class Mat(object):
	"""Mat class"""
	def __init__(self):
		self.yam = Yml()

	@staticmethod
	def begin(filename):
		info = inf.Inf()
		print('%')
		print('% {0}.m'.format(filename))
		print('% (max, +) system description')
		print('% automatically generated by {0} ver.{1} on {2}'.format(info.NAME, info.VERSION, info.get_time()))
		print('% Copyright (c) 2017-2019 {0} <{1}>'.format(info.AUTHOR, info.AUTHOR_EMAIL))
		print('%\n')
		print('clear\n')
		return Err.NOOP

	def do_matrices(self, matrix, name, vec, iter):
		if iter:
			index = iter
		else:
			index = 0
		mat = ''
		if not matrix:
			return mat
		if self.yam.empty_matrix(matrix):
			return mat
		for i in range(0, len(matrix)):
			if matrix[i]:
				if len(mat):
					mat = mat + ' + '
				index = index - i
				tmp = ''
				if index > 0:
					tmp = '+{0}'.format(index)
				elif index < 0:
					tmp = '{0}'.format(index+1)
				if iter is None:
					mat = mat + '{0}{1}(k{2})'.format(name, vec, tmp)
				else:
					mat = mat + '{0}{1}{2}(k{3})'.format(name, i, vec, tmp)
		return mat

	def equation(self, mat_A, mat_B, mat_C, mat_D):
		print('disp(\'x(k+1) = ', end='')
		mat = self.do_matrices(mat_A, 'A', 'x', 1)
		if len(mat):
			print(mat, end='')
			mat = self.do_matrices(mat_B, 'B', 'u', 0)
			if len(mat):
				print(' +', mat, end='')
		print('\');')
		print('disp(\'y(k) = ', end='')
		mat = self.do_matrices(mat_C, 'C', 'x', None)
		if len(mat):
			print(mat, end='')
		mat = self.do_matrices(mat_D, 'D', 'u', None)
		if len(mat):
			print(' +', mat, end='')
		print('\');')
		return Err.NOOP

	@staticmethod
	def clean_value(value):
		ans = ''
		for i, _ in enumerate(value):
			if value[i] not in ['{', '}', '_', ',']:
				ans += value[i]
		return ans

	def time_values(self, values):
		if values:
			for key in sorted(values):
				print('%s = %s' % (self.clean_value(key), values[key]))
		return Err.NOOP

	@staticmethod
	def vector(name, vector):
		print('disp(\'{0}(k) = ['.format(name), end='')
		for i, _ in enumerate(vector):
			print(' {0}(k);'.format(vector[i]), end='')
		print(' ]\');')
		return Err.NOOP

	def get_matrix_value(self, tab):
		if not tab:
			return '0'
		if tab == '-':
			return tab
		odp = ''
		tmp = ''
		for i, _ in enumerate(tab):
			if len(tab) > 1 and i > 0:
				odp = 'mp_multi({0}, '.format(tmp)
			tmp = str(self.clean_value(tab[i]))
			odp += tmp
			if len(tab) > 1 and i > 0:
				odp += ')'
		return odp

	@staticmethod
	def matrix_desc():
		print('disp(\'matrices:\');')
		return Err.NOOP

	def matrix(self, name, idx_name, matrix):
		print('% matrix {0}{1}'.format(name, idx_name))
		w1, w2 = self.yam.get_matrix_size(matrix)
		print('{0}{1} = mp_zeros({2}, {3});'.format(name, idx_name, w1, w2))
		for i in range(0, w1):
			for j in range(0, w2):
				if matrix[i][j] != '-':
					print('   {0}{1}({2}, {3}) = {4};'.format(
						name, idx_name, i + 1, j + 1, self.get_matrix_value(matrix[i][j])
					))
		print('   {0}{1}'.format(name, idx_name))
		print()
		return Err.NOOP

	@staticmethod
	def input_vec(vec):
		print('U  = mp_ones({0}, {1})'.format(len(vec), 1))
		return Err.NOOP

	@staticmethod
	def start_vec(vec):
		print('X0 = mp_zeros({0}, {1})'.format(len(vec), 1))
		return Err.NOOP

	@staticmethod
	def adds():
		print('' + \
			'disp(\'model:\');\n' + \
			'As = mp_star(A0)\n' + \
			'A = mp_multi(As, A1)\n' + \
			'B = mp_multi(As, B0)\n' + \
			'\n' + \
			'disp(\'state vector and output:\');\n' + \
			'% number of iterations\n' + \
			'k = 12;\n' + \
			'X(:, 1) = mp_add(mp_multi(A, X0), mp_multi(B, U));\n' + \
			'Y(:, 1) = mp_multi(C, X(:, 1));\n' + \
			'for i = 2:k\n' + \
			'    X(:, i) = mp_add(mp_multi(A, X(:, i - 1)), mp_multi(B, U));\n' + \
			'    Y(:, i) = mp_multi(C, X(:, i));\n' + \
			'end\n' + \
			'X\n' + \
			'Y\n')
		return Err.NOOP

	@staticmethod
	def end():
		print('\n% eof\n')
		return Err.NOOP

	def inits(self, vec_u, vec_x, values):
		print('\ndisp(\'initial vectors:\');')
		self.input_vec(vec_u)
		self.start_vec(vec_x)
		print('\ndisp(\'times:\');')
		self.time_values(values)
		return Err.NOOP

	def vectors(self, vec_u, vec_x, vec_y):
		print()
		self.vector('u', vec_u)
		self.vector('x', vec_x)
		self.vector('y', vec_y)
		return Err.NOOP

# eof.
